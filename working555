#!/bin/bash

# Ensure Python3 is installed and accessible
PYTHON=$(which python3)

# Define Python script inline
PYTHON_SCRIPT=$(cat <<EOF
import os
import argparse
import numpy as np
import xml.etree.ElementTree as ET
import torch
from tensorflow.keras.preprocessing.image import load_img, img_to_array

# Your model class (replace with the actual model class)
class YourModelClass(torch.nn.Module):
    def __init__(self):
        super(YourModelClass, self).__init__()
        # Define your model architecture here

    def forward(self, x):
        pass  # Replace with forward pass logic

# Function to load and preprocess images
def load_images(image_dir, user_ids):
    images = []
    for user_id in user_ids:
        img_path = os.path.join(image_dir, f"{user_id}.jpg")
        if os.path.exists(img_path):
            img = load_img(img_path, target_size=(128, 128))  # Resize images to match model input
            img_array = img_to_array(img) / 255.0  # Normalize pixel values
            images.append(img_array)
        else:
            print(f"Warning: Image {img_path} not found.")
    return np.array(images)

# Function to generate fake trait values for demo purposes
def generate_personality_traits():
    return {
        "extrovert": round(np.random.uniform(2.5, 5.0), 2),
        "neurotic": round(np.random.uniform(2.5, 5.0), 2),
        "agreeable": round(np.random.uniform(2.5, 5.0), 2),
        "conscientious": round(np.random.uniform(2.5, 5.0), 2),
        "open": round(np.random.uniform(2.5, 5.0), 2)
    }

# Function to write XML output
def write_xml(user_id, age_group, gender, traits, output_dir):
    # Create XML structure
    user = ET.Element("user", attrib={
        "id": user_id,
        "age_group": age_group,
        "gender": "female" if gender == 1 else "male",
        "extrovert": str(traits["extrovert"]),
        "neurotic": str(traits["neurotic"]),
        "agreeable": str(traits["agreeable"]),
        "conscientious": str(traits["conscientious"]),
        "open": str(traits["open"])
    })
    # Write to XML file
    tree = ET.ElementTree(user)
    output_path = os.path.join(output_dir, f"{user_id}.xml")
    tree.write(output_path)

# Function to load the model
def load_model():
    MODEL_PATH = os.path.expanduser("~/model2.pth")
    if not os.path.exists(MODEL_PATH):
        raise FileNotFoundError(f"Model file not found at {MODEL_PATH}")

    checkpoint = torch.load(MODEL_PATH, map_location=torch.device('cpu'))

    if 'model.state_dict' in checkpoint:
        model = YourModelClass()  # Replace with the actual class for your model
        model.load_state_dict(checkpoint['model.state_dict'])
    else:
        model = YourModelClass()  # Replace with the actual class
        model.load_state_dict(checkpoint)

    # Optionally handle additional keys
    if 'cnn_output_dim' in checkpoint:
        print(f"CNN Output Dim: {checkpoint['cnn_output_dim']}")

    if 'scaler' in checkpoint:
        print("Scaler loaded.")

    model.eval()  # Set model to evaluation mode
    return model

# Main function
def main(input_dir, output_dir):
    # Ensure output directory exists
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    # Load model
    model = load_model()

    # Load user IDs from input directory
    user_ids = [file.split('.')[0] for file in os.listdir(input_dir) if file.endswith(".jpg")]

    # Load and preprocess images
    images = load_images(input_dir, user_ids)

    # Predict gender
    predictions = model(torch.tensor(images).permute(0, 3, 1, 2))  # Adjust for PyTorch input format
    predicted_genders = torch.argmax(predictions, axis=1).numpy()

    # Generate XML output for each user
    for user_id, gender in zip(user_ids, predicted_genders):
        # Assign random age group for demonstration (modify as needed)
        age_group = "xx-24"  # Placeholder age group
        traits = generate_personality_traits()
        write_xml(user_id, age_group, gender, traits, output_dir)

    print(f"Prediction and XML generation complete. Results saved to {output_dir}")

# Parse command-line arguments
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Gender Prediction Script")
    parser.add_argument("-i", "--input", required=False, help="Path to input test data (directory containing .jpg files)", default="image")
    parser.add_argument("-o", "--output", required=True, help="Path to output directory for XML files")
    args = parser.parse_args()

    # Check if default 'image' folder exists when no input path is provided
    if args.input == "image" and not os.path.exists("image"):
        raise FileNotFoundError("Default folder 'image' not found. Provide a valid input directory.")

    main(args.input, args.output)
EOF
)

# Run the Python code
$PYTHON -c "$PYTHON_SCRIPT" "$@"
