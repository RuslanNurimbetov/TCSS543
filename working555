import os
import argparse
import numpy as np
import xml.etree.ElementTree as ET
import torch
from tensorflow.keras.preprocessing.image import load_img, img_to_array

# Define the GenderModel class or load the correct model class definition
class GenderModel(torch.nn.Module):
    def __init__(self):
        super(GenderModel, self).__init__()
        # Define the layers of your model (this is a placeholder example)
        self.fc = torch.nn.Linear(128 * 128 * 3, 2)  # Adjust according to your model

    def forward(self, x):
        return self.fc(x)

# Function to load and preprocess images
def load_images(image_dir, user_ids):
    images = []
    for user_id in user_ids:
        img_path = os.path.join(image_dir, f"{user_id}.jpg")
        if os.path.exists(img_path):
            img = load_img(img_path, target_size=(128, 128))  # Resize images to match model input
            img_array = img_to_array(img) / 255.0  # Normalize pixel values
            images.append(img_array)
        else:
            print(f"Warning: Image {img_path} not found.")
    return np.array(images)

# Function to generate fake trait values for demo purposes
def generate_personality_traits():
    return {
        "extrovert": round(np.random.uniform(2.5, 5.0), 2),
        "neurotic": round(np.random.uniform(2.5, 5.0), 2),
        "agreeable": round(np.random.uniform(2.5, 5.0), 2),
        "conscientious": round(np.random.uniform(2.5, 5.0), 2),
        "open": round(np.random.uniform(2.5, 5.0), 2)
    }

# Function to write XML output
def write_xml(user_id, age_group, gender, traits, output_dir):
    # Create XML structure
    user = ET.Element("user", attrib={
        "id": user_id,
        "age_group": age_group,
        "gender": "female" if gender == 1 else "male",
        "extrovert": str(traits["extrovert"]),
        "neurotic": str(traits["neurotic"]),
        "agreeable": str(traits["agreeable"]),
        "conscientious": str(traits["conscientious"]),
        "open": str(traits["open"])
    })
    # Write to XML file
    tree = ET.ElementTree(user)
    output_path = os.path.join(output_dir, f"{user_id}.xml")
    tree.write(output_path)

# Function to load the model
def load_model():
    model = GenderModel()  # Replace with the actual model class you are using
    model_path = os.path.expanduser("~/model2.pth")

    # Load the entire saved state
    state = torch.load(model_path, map_location=torch.device('cpu'))

    # If the state has unexpected keys, extract only the model's state_dict
    if "model_state_dict" in state:
        model.load_state_dict(state["model_state_dict"])
    else:
        model.load_state_dict(state)  # Fallback for plain state dicts

    return model

# Main function
def main(input_dir, output_dir):
    # Ensure output directory exists
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    # Load model
    model = load_model()
    model.eval()

    # Load user IDs from input directory
    user_ids = [file.split('.')[0] for file in os.listdir(input_dir) if file.endswith(".jpg")]

    # Load and preprocess images
    images = load_images(input_dir, user_ids)

    # Flatten images for the placeholder model (adjust preprocessing as per your model)
    images = images.reshape(images.shape[0], -1)

    # Convert to tensor
    images_tensor = torch.tensor(images, dtype=torch.float32)

    # Predict gender
    with torch.no_grad():
        predictions = model(images_tensor)
        predicted_genders = torch.argmax(predictions, axis=1).numpy()

    # Generate XML output for each user
    for user_id, gender in zip(user_ids, predicted_genders):
        # Assign random age group for demonstration (modify as needed)
        age_group = "xx-24"  # Placeholder age group
        traits = generate_personality_traits()
        write_xml(user_id, age_group, gender, traits, output_dir)

    print(f"Prediction and XML generation complete. Results saved to {output_dir}")

# Parse command-line arguments
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Gender Prediction Script")
    parser.add_argument("-i", "--input", required=False, help="Path to input test data (directory containing .jpg files)", default="image")
    parser.add_argument("-o", "--output", required=True, help="Path to output directory for XML files")
    args = parser.parse_args()

    # Check if default 'image' folder exists when no input path is provided
    if args.input == "image" and not os.path.exists("image"):
        raise FileNotFoundError("Default folder 'image' not found. Provide a valid input directory.")

    main(args.input, args.output)
